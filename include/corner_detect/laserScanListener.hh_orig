#include "ros/ros.h"
#include "tf/transform_listener.h"
#include "sensor_msgs/PointCloud.h"
#include "tf/message_filter.h"
#include "message_filters/subscriber.h"
#include "laser_geometry/laser_geometry.h"
#include <pcl_conversions/pcl_conversions.h>
#include <pcl/point_types.h>
#include <pcl/PCLPointCloud2.h>
#include <pcl/conversions.h>
#include <pcl_ros/transforms.h>
#include "filters/filter_chain.h"
#include <math.h>
#define BREAKPOINT 1
#define CORNER 2

class LaserScanListener{

//public:
  struct PointParamters
  {
    int pointType;
    int kf;
    int kb;
    float theta;
    float ci;
  };
  ros::NodeHandle rn;
  laser_geometry::LaserProjection lprojector;
  tf::TransformListener tf_listener;
  message_filters::Subscriber<sensor_msgs::LaserScan> laser_sub;
  tf::MessageFilter<sensor_msgs::LaserScan> laser_notifier;
  //sensor_msgs::LaserScan::Ptr scan;
  //sensor_msgs::LaserScan::iterator scan_iter;
  std::vector<float>::iterator scan_ranges_iter;
  std::vector<float>::iterator scan_inten_iter;
  pcl::PointCloud<pcl::PointXYZ>::Ptr pcl_cloud;
  sensor_msgs::PointCloud2::Ptr cloud_ptr;
  //sensor_msgs::PointCloud2Iterator<sensor_msgs::PointCloud2> cl_it;
  //pcl::CloudIterator<pcl::PointXYZI> pcl_iter;
  pcl::PointCloud<pcl::PointXYZ>::iterator pcl_iter;
  //filters::FilterChain<sensor_msgs::LaserScan> filter_chain;
  float theta_min;
  ros::Publisher p_pub;
  std::vector <PointParamters> *p_param;
  std::vector<PointParamters>::iterator ppit;
  

  public: LaserScanListener(ros::NodeHandle);
  public: ~LaserScanListener();
  protected: void scanCallback(const sensor_msgs::LaserScan::ConstPtr&);
  protected: void detectBreakPoint(const sensor_msgs::LaserScan& scan);
  protected: void detectLineSegments();
  protected: void detectCurveAndCorner();
  protected: float computeEuclidDist(pcl::PointCloud<pcl::PointXYZ>::iterator,pcl::PointCloud<pcl::PointXYZ>::iterator);
  protected: void publishPoint(pcl::PointCloud<pcl::PointXYZ>::iterator,int);

};


